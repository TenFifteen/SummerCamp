 Search Range in Binary Search Tree 二叉树中序遍历 easy
 Min Stack	最小栈 栈里存储与最小值的差即可
 strStr	查子串是否存在。 strlen(const char* s),遍历操作与string一致。练习kmp
 First Position of Target	二分查找，左边界。
 Permutations	不重复元素排列。对当前下标与后面每一位换位置，需reset。
 Permutations II	重复元素排列。排序后，对当前下标和后面非相等元素换位置，不需要reset
 Subsets	求所有子集。for递归。也可用位操作。
 Subsets II	求有重复元素的所有子集。排序，循环。对重复元素取1-n个加入已有集合中。
 Binary Tree Serialization	二叉树序列化和反序列化。先序遍历保存成字符串。反序列化反之。
 Search a 2D Matrix	二分查找。 easy
 Search a 2D Matrix II	每次去掉一行或者一列
 Search in Rotated Sorted Array	二分。判断左边和右边哪边有序，然后判断target是否在有序的一半
 Search in Rotated Sorted Array II 	在旋转矩阵中查找元素。注意A[mid]与同一边比较。
 Find Minimum in Rotated Sorted Array    在旋转矩阵中找最小值。
 Find Minimum in Rotated Sorted Array II    在有重复元素的旋转矩阵中找最小值。
 Recover Rotated Sorted Array	恢复有重复元素的旋转矩阵。先找最小元素的位置。
 interleaving String	字符串动归。
 Insert Interval	插入区间。先找插入位置，左边界，再找右边界。最后插入合并的新区间，并删除被合并的区间。
 Partition Array	划分。swap（nums[low],nums[high]）.不需要交换两次。
 Minimum Window Substring	包含target所有字符的最短子串。map和counter结合应用。维持窗口，然后最大程度收缩窗口。
 Reverse Linked List 翻转字符串。
 Reverse Linked List II    翻转m到n的字符串。前半部分顺序添加到新链表尾部，m到n的部分逆序添加。
 Implement Queue by Two Stacks	两个栈实现一个队列。easy
 N-Queens 	n皇后所有方案。递归。
 N-Queens II    n皇后方案数。
 Maximum Subarray	最大连续子序列和。
 Maximum Subarray II    两段最大连续字段和。动归，先从前往后扫一遍，记录到当前位置i的最大连续字段和，再从后往前扫，两段相加求最大。
 Maximum Subarray III	k段最大连续字段和。动归，转移方程为f[i][j] = max(f[i][j], f[i][j - 1], max(f[i - 1][m] + m-j连续和))
 Minimum Subarray	最小连续字段和。
 Maximum Subarray Difference	求数组中两个子集A和B的最大差, |SUM(A) - SUM(B)|.综合最大字段和、最小字段和、两段最大和。对i，res= max(leftmax[i - 1] - rightmin[i], rightmax[i] - leftmin[i - 1]);
 Majority Number	超过一半的数。
 Majority Number II    超过1/3的数。
 Majority Number III 超过1/k的数。用数组保存当前的k个数，如果当前数与其中一个相等或者其中一个count==0，则count+1；否则，所有数组中的数的count--；
 Sort Letters by Case	前面小写后面大写。两个指针分别从头往后扫。
 Product of Array Exclude Itself	除了自身其他所有数的乘积，不用除法。从左往右扫记录left[i]，从右往左扫计算res。
 Previous Permutation    前一个排列。找第一个nums[i] > nums[i + 1]的位置，与后面小于该数的最大数交换，然后逆序即可。
 Next Permutation    后一个排列。同前一个排列。
 String to Integer II    字符串转整数。注意前有+，-以及long long也可能超的情况。
 Reverse Words in a String    翻转字符串。先去掉多余空格，然后全部逆序，再对每个单词分别逆序即可。注意第一个和最后一个位置的处理。
 Compare Strings	判断字符串B的字符是否都在A中，开始用了动归，后发现只需要对字符个数操作即可。
 2Sum    返回两个数的和为target的数的下标。先排序，然后找到两个数后，到原数组中找两个数的下标。更简单的方法是用hashmap
 3Sum	三数之和为0.排序，定一个数，另两个数用2-sum的方法。
 4Sum	四数之和为target.排序。定两个数，另两个数两个指针往中间扫。
 3Sum Closest	思路同3sum,只是求的是最接近target。
 Search Insert Position	查插入位置。二分。
 Search for a Range	查一个数出现的左右边界。二分，找左右边界。
 Merge Sorted Array	合并两个有序数组。
 Median of two Sorted Arrays***	求两个有序数组的中位数。中位数的位置即是，两个数组左半边都小于右半边。
 Binary Tree Preorder Traversal	二叉树先序遍历。
 Binary Tree Inorder Traversal	中序遍历。
 Binary Tree Postorder Traversal	后序遍历。
 Binary Tree Level Order Traversal	层次遍历。
 Binary Tree Level Order Traversal II   自底向上层次遍历。
 Binary Tree Zigzag Level Order Traversal	从左到右、从右到左交替遍历树。设置flag，来决定当前遍历的顺序是否需要逆序即可。
 First Bad Version	二分。
 Find Peak Element	找峰值。二分。比较A[mid],A[mid-1], A[mid+1]的元素。
 Median	找中位数。用找第k大的数的方法即可。快排的思想。
 Data Stream Median	数据流中位数，随时输出中位数。维护大顶堆和小顶堆。
 Construct Binary Tree from Inorder and Postorder Traversal	后序和中序重建二叉树。
 Construct Binary Tree from Preorder and Inorder Traversal	先序和中序重建二叉树。
 Longest Increasing Subsequence	最长递增子序列。动归，用数组记录长度为i的最小数。
 Longest Common Subsequence	最长公共子序列。动归.
 Longest Common Prefix	最长公共前缀。遍历即可。
 Longest Common Substring	最长公共子串。动归。
 Single Number	其他数都出现两次，只有一个出现一次的数。所有数异或。
 Single Number II    其他数都出现三次，只有一个出现一次的数。one，two，three分别记录每位出现1，2，3次的数。
 Single Number III	其他数出现两次，只有两个数出现一次。两次异或。&运算优先级低，注意加括号(res & A[i]) == 0
 ***K SUM   n个不同的数里选取k个使得和为target。三维动归。f[i][j][k]表示成前i个数里挑出j个数使得和为k。
 k Sum II    k数之和等于target的所有方案数。递归。
 Insert Node in a Binary Search Tree	二叉搜索树中插入节点。
 ***Binary Search Tree Iterator	设计数据结构实现二叉树迭代器。用栈实现。
 Lowest Common Ancestor	最低公共祖先。
 ***Remove Node in Binary Search Tree	移出二叉搜索树中的一个节点。递归实现很简洁。
 Backpack	给定物品体积和背包容量。最大程度装满背包。二维动归。f[i][j] ||= f[i - 1][j]|| f[i - 1][j - A[i - 1]];
 Backpack II    给定物品体积和物品价值，背包容量。求最大能获得的价值。二维动归。f[i][j] = max(f[i][j], f[i - 1][j]， f[i - 1][j - A[i - 1]] + V[i - 1]);
 Balanced Binary Tree	判断是否是平衡二叉树。递归。
 Binary Tree Maximum Path SUM   树的最大路径和。左右子树递归。
 Validate Binary Search Tree	判断是否为二叉搜索树。左子树的最大值小于当前节点且右子树的最小值大于当前节点。
 Partition List	链表划分。建两个新表头即可。
 Maximum Depth of Binary Tree	树的最大深度。递归。
 Sort List	链表排序。归并排序。
 Reorder List	链表重排。先找到链表中部，然后将后一段逆序，然后两段一个一个接起来。
 Remove Duplicates from Sorted Array    移出有序数组中的重复元素。
 Remove Duplicates from Sorted Array II    移出有序数组中的超过两次的重复元素。
 Linked List Cycle	判断链表是否有环。快慢指针。
 Linked List Cycle II	判断链表环的开始位置。快慢指针。
 Merge k Sorted Lists	归并k个有序链表。
 Copy List with Random Pointer	拷贝链表，链表中有指向随机节点的指针。
 Convert Sorted List to Balanced BST	将链表转换为平衡二叉树。快慢指针。
 **Word Break	判断字符串s能否由字典dict中的单词组成。动归。注意对字典中最长单词长度maxlen的应用，不然会超时。
 Triangle	三角形从上到下最短路径。动归。注意每行从后往前！！
 Minimum Path Sum    m*n区域最短路径和。 动归。
 **Palindrome Partitioning	将字符串s切成回文子串的所有方案。可循环或递归解。
 ***Palindrome Partitioning II    将字符串切成回文子串的最小割。动归。注意初始化，注意f[i]值更新方法。
 Climbing Stairs	爬梯子的方案数。f[n]=f[n-1]+f[n-2]
 Remove Duplicates from Sorted List    去除有序链表中的重复元素。
 Remove Duplicates from Sorted List II    去除有序链表中的重复元素，只剩不同的元素。
 Unique Paths	从m*n格子左上角到右下角的路径数。选择数。
 Unique Paths II    从m*n有障碍的格子左上角到右下角的路径数。动归。
 Jump Game    开始处于下标为0的位置，每次最多可跳A[i]下，问能否跳到数组最后一个位置。贪心。
 Jump Game II    开始处于下标为0的位置，每次最多可跳A[i]下，问跳到数组最后一个位置需要的最少跳数。贪心+bfs。
 Edit Distance    最小编辑距离。动归。注意四种情况。
 Distinct Subsequences	在S中不同的子序列T的数目。动归。f[i][j] += f[i - 1][j - 1]+f[i - 1][j];
 ***Minimum Adjustment Cost    最小编辑距离。动归。
 **Largest Rectangle in Histogram	条形图中的最大矩形。栈中保存一个递增的序列。
 Longest Consecutive Sequence    最长连续序列。hash。
 Topological Sorting	图的拓扑排序。
 Hash Function	将字符串用哈希函数转为整数。注意时刻%。
 Rehashing	扩大哈希size为原来两倍，重构hash。
 Heapify	给定一个数组，调整成最小堆。从最后一个父节点l/2-1调整至0即可。
 ***Building Outline	给定一些建筑物起始点和高度，求建筑物的外部轮廓。
 Longest Words	扫一遍，输出字典中的最长字符串。
 *LRU Cache	哈希+双向链表。
 Combination Sum    用数组中的数组合成target，每个数可取多次。递归。
 Combination Sum II    用数组中的数组合成target。递归。
 Combinations	从1-n个数中选出k个数，所有的组合。递归。
 Clone Graph    复制一个图。注意map的使用，在创建新节点后马上加入map，否则容易造成循环。
 Fast Power	计算a^n % b。二分。
 Sqrt(x)	二分。注意用乘积用long long。
 ***Subarray Sum    子数组和为0.
 ***Subarray Sum Closest	子数组和最接近0.
 O(1) Check Power of 2	O(1)时间判断一个数是否是2的次幂。n > 0 && (n & (n - 1)) == 0
 Sort Colors	将数组中散乱的三种颜色各个颜色分别放在一起。
 ***Sort Colors II   将k个颜色分别放到一起。快排思想。用vector做桶。
 **Interleaving Positive and Negative Numbers	将数组正数和负数穿插。
 *Regular Expression Matching	.*正则表达式匹配。
 *Wildcard Matching	?*正则表达式匹配。
 Minimum Depth of Binary Tree	二叉树的最小深度。
 *Word Search	在二维字符数组中查找单词。dfs
 ***Word Search II    在二维字符数组中查找一组单词。字典树+dfs。注意利用字典树的位置以及更新visited的位置,以及利用set去重。






